# -*- coding: utf-8 -*-
"""New PCOS2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1sGPZWCb3qBi6gy6QQxrJ88Snu_whsLGt
"""

# -*- coding: utf-8 -*-
"""PCOS_Model.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Ssh9tXmsT3gYQ-7PWBc3J3c55F3xhAdj
"""

import pandas as pd
import numpy as np
import pickle

df=pd.read_csv("data.csv")

df.columns

new=pd.DataFrame(df)

new

new.reset_index(drop=True,inplace=True)
new

new.drop(['Sl. No','Patient File No.','Blood Group','FSH(mIU/mL)','LH(mIU/mL)','FSH/LH','Hip(inch)','Waist(inch)','Waist:Hip Ratio','TSH (mIU/L)','AMH(ng/mL)','PRL(ng/mL)','Vit D3 (ng/mL)','PRG(ng/mL)','RBS(mg/dl)','Follicle No. (L)','Follicle No. (R)','Avg. F size (L) (mm)','Avg. F size (R) (mm)','Endometrium (mm)','Pulse rate(bpm) ','RR (breaths/min)', 'Hb(g/dl)','  I   beta-HCG(mIU/mL)', 'II    beta-HCG(mIU/mL)','Unnamed: 44','Cycle(R/I)','BMI'],axis=1,inplace=True)

new.columns

new

y=new['PCOS (Y/N)']

y.head()

new.drop('PCOS (Y/N)',axis=1,inplace=True)
new

new.info()

new['Marraige Status (Yrs)'].fillna(new['Marraige Status (Yrs)'].median(),inplace=True)
new['Fast food (Y/N)'].fillna(new['Fast food (Y/N)'].median(),inplace=True)
new

new.info()

new.isnull().sum()

#converting dataframe to array
xnew=new.values
ynew=y.values

from sklearn.preprocessing import MinMaxScaler
scaler=MinMaxScaler(copy=True)
scaler.fit(xnew)
x_scaled=scaler.transform(xnew)

from sklearn.model_selection import train_test_split
x_train,x_test,y_train,y_test=train_test_split(xnew,ynew,random_state=3)

from sklearn.metrics import classification_report,confusion_matrix

# SVC

from sklearn.svm import SVC
clf=SVC(kernel='poly',degree=2,C=0.01)
clf.fit(x_train,y_train)
ypredsvm=clf.predict(x_test)
clf.score(x_train,y_train),clf.score(x_test,y_test)

# Decision Tree Classifier

from sklearn.tree import DecisionTreeClassifier
clf1=DecisionTreeClassifier()
clf1.fit(x_train,y_train)
ypredDT=clf1.predict(x_test)
clf1.score(x_train,y_train),clf1.score(x_test,y_test)

new.columns

clf1.feature_importances_

# Naive Bayes
from sklearn.naive_bayes import GaussianNB
clf2=GaussianNB()
clf2.fit(x_train,y_train)
ypredNB=clf2.predict(x_test)
clf2.score(x_train,y_train),clf2.score(x_test,y_test)

# Linear Regression
from sklearn.linear_model import LinearRegression
clf5=LinearRegression()
clf5.fit(x_train,y_train)
ypredLR=clf5.predict(x_test)
clf5.score(x_train,y_train),clf5.score(x_test,y_test)

# Logistic Regression
from sklearn.linear_model import LogisticRegression
clf3 = LogisticRegression(C=0.01)
clf3.fit(x_train,y_train)
ypredLR=clf3.predict(x_test)
clf3.score(x_train,y_train),clf3.score(x_test,y_test)

# KNeighbors Classifier
from sklearn.neighbors import KNeighborsClassifier
clf6=KNeighborsClassifier(n_neighbors=3)
clf6.fit(x_train,y_train)
ypredKNN=clf6.predict(x_test)
clf6.score(x_train,y_train),clf6.score(x_test,y_test)

# Random Forest Classifier
from sklearn.ensemble import RandomForestClassifier
clf7 = RandomForestClassifier(criterion="entropy")
clf7.fit(x_train, y_train)
ypredRF=clf7.predict(x_test)
clf7.score(x_train,y_train),clf7.score(x_test,y_test)



from sklearn.model_selection import StratifiedKFold

def Stacking(model,train,y,test,n_fold):
    folds=StratifiedKFold(n_splits=n_fold,random_state=1)
    test_pred=np.empty((test.shape[0],1),float)
    train_pred=np.empty((0,1),float)
    for train_indices,val_indices in folds.split(train,y.values):
        x_train,x_val=train.iloc[train_indices],train.iloc[val_indices]
        y_train,y_val=y.iloc[train_indices],y.iloc[val_indices]

        model.fit(X=x_train,y=y_train)
        train_pred=np.append(train_pred,model.predict(x_val))
        test_pred=np.append(test_pred,model.predict(test))
    return test_pred.reshape(-1,1),train_pred

xtrain=pd.DataFrame(x_train)
ytrain=pd.DataFrame(y_train)
xtest=pd.DataFrame(x_test)
test_pred1 ,train_pred1=Stacking(model=clf6,n_fold=5, train=xtrain,test=xtest,y=ytrain)
test_pred2 ,train_pred2=Stacking(model=clf1,n_fold=5, train=xtrain,test=xtest,y=ytrain)
test_pred3 ,train_pred3=Stacking(model=clf,n_fold=5, train=xtrain,test=xtest,y=ytrain)

train_pred1=pd.DataFrame(train_pred1)
test_pred1=pd.DataFrame(test_pred1)

train_pred2=pd.DataFrame(train_pred2)
test_pred2=pd.DataFrame(test_pred2)

train_pred3=pd.DataFrame(train_pred3)
test_pred3=pd.DataFrame(test_pred3)

test_pred1=test_pred1.iloc[:41]
test_pred2=test_pred2.iloc[:41]
test_pred3=test_pred3.iloc[:41]

df_train = pd.concat([train_pred1, train_pred2, train_pred3], axis=1)
df_test = pd.concat([test_pred1, test_pred2,test_pred3], axis=1)

#ytest=pd.DataFrame(y_test)
#model = RandomForestClassifier(random_state=1,criterion="entropy")
#model.fit(df_train,y_train)
#model.score(df_test,y_test)

# Bagging
from sklearn. ensemble import BaggingClassifier, AdaBoostClassifier, VotingClassifier
bg = BaggingClassifier(clf3, max_samples= 0.5, max_features = 1.0, n_estimators = 20)
bg.fit(x_train,y_train)
bg.score(x_test,y_test)

# Boosting - Ada Boost
adb = AdaBoostClassifier(LogisticRegression(),n_estimators = 5, learning_rate = 1)
adb.fit(x_train,y_train)
adb.score(x_test,y_test)

evc = VotingClassifier( estimators= [('svm',clf),('dt',clf1),('nb',clf2),('lr',clf3),('knn',clf6)], voting = 'hard')
evc.fit(x_train,y_train)
evc.score(x_test, y_test)

from sklearn.cluster import KMeans
from sklearn.metrics import mean_squared_error
kmeans=KMeans(n_clusters=2)

ypredKn=[]
kmeans.fit(x_train)
for i in kmeans.labels_:
    ypredKn.append(int(not i))
rmse=mean_squared_error(ypredKn,y_train)
rmse

from sklearn.model_selection import cross_val_score
x_axis=[]
y_axis=[]
for i in range(1,14):
    clf=KNeighborsClassifier(n_neighbors=i)
    score=cross_val_score(clf,x_test,y_test)
    x_axis.append(i)
    y_axis.append(score.mean())
    print(i,score.mean())

print(cross_val_score(clf,x_test,y_test))
print(cross_val_score(clf1,x_test,y_test))
print(cross_val_score(clf2,x_test,y_test))
print(cross_val_score(clf3,x_test,y_test))

pickle.dump(evc,open('model.pkl','wb'))

model=pickle.load(open('model.pkl','rb'))

